"""
Vocal generation service using Bark TTS (Expressive Singing AI)
"""
import asyncio
import uuid
import logging
import numpy as np
import scipy.io.wavfile as wavfile
from pathlib import Path
from pydub import AudioSegment
from transformers import AutoProcessor, BarkModel
import torch
from typing import Optional
from app.config import settings

logger = logging.getLogger(__name__)


class BarkModelCache:
    """Singleton cache for Bark model to avoid reloading"""
    _instance = None
    _model = None
    _processor = None
    _device = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def get_model_and_processor(self):
        """Load and cache Bark model and processor"""
        if self._model is None or self._processor is None:
            logger.info(f"Loading Bark model: {settings.BARK_MODEL}")

            # Load processor
            self._processor = AutoProcessor.from_pretrained(settings.BARK_MODEL)

            # Load model
            self._model = BarkModel.from_pretrained(
                settings.BARK_MODEL,
                torch_dtype=torch.float16 if settings.BARK_USE_GPU else torch.float32
            )

            # Move to GPU if available and enabled
            if settings.BARK_USE_GPU and torch.cuda.is_available():
                self._device = "cuda"
                self._model = self._model.to(self._device)
                logger.info("Bark model loaded on GPU (CUDA)")
            else:
                self._device = "cpu"
                self._model = self._model.to(self._device)
                logger.info("Bark model loaded on CPU")

            logger.info("Bark model and processor loaded successfully")

        return self._model, self._processor, self._device


class VocalGenerator:
    """Generate expressive singing vocals using Bark TTS"""

    def __init__(self):
        """Initialize Bark TTS with cached model"""
        self.voice_preset = settings.BARK_VOICE_PRESET
        self.singing_mode = settings.BARK_SINGING_MODE
        self.sample_rate = settings.SAMPLE_RATE

        # Get cached model, processor, and device
        cache = BarkModelCache()
        self.model, self.processor, self.device = cache.get_model_and_processor()

        logger.info(f"VocalGenerator initialized with voice: {self.voice_preset} on device: {self.device}")

    async def generate_vocals_async(
        self,
        lyrics: str,
        output_path: str = None
    ) -> str:
        """
        Generate vocals using Bark TTS (async wrapper)

        Args:
            lyrics: The lyrics text
            output_path: Optional output path (generates unique if not provided)

        Returns:
            Path to generated audio file (MP3)
        """
        # Run in thread pool to avoid blocking
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, self._generate_vocals_sync, lyrics, output_path)

    def generate_vocals(self, lyrics: str, output_path: str = None) -> str:
        """
        Synchronous vocal generation

        Args:
            lyrics: The lyrics text
            output_path: Optional output path

        Returns:
            Path to generated audio file (MP3)
        """
        return self._generate_vocals_sync(lyrics, output_path)

    def _generate_vocals_sync(self, lyrics: str, output_path: Optional[str] = None) -> str:
        """
        Internal synchronous generation method with chunking optimization

        Args:
            lyrics: The lyrics text
            output_path: Optional output path

        Returns:
            Path to generated MP3 file
        """
        try:
            # Generate unique filename if not provided
            if output_path is None:
                filename = f"vocals_{uuid.uuid4()}.mp3"
                output_path = str(settings.TEMP_DIR / filename)

            # Ensure output is MP3
            if not output_path.endswith('.mp3'):
                output_path = output_path.replace('.wav', '.mp3')

            logger.info(f"Generating vocals with Bark TTS to {output_path}")

            # Format and split lyrics into optimal chunks
            formatted_lyrics = self._format_for_singing(lyrics)
            chunks = self._split_into_chunks(formatted_lyrics)

            logger.info(f"Split lyrics into {len(chunks)} chunks for better quality")

            # Generate audio for each chunk
            audio_segments = []
            sample_rate = self.model.generation_config.sample_rate

            for i, chunk in enumerate(chunks):
                logger.debug(f"Generating chunk {i+1}/{len(chunks)}: {chunk[:50]}...")

                # Prepare inputs for this chunk
                inputs = self.processor(
                    chunk,
                    voice_preset=self.voice_preset,
                    return_tensors="pt"
                )

                # Move inputs to same device as model
                inputs = {k: v.to(self.device) for k, v in inputs.items()}

                # Generate audio with optimized parameters
                with torch.no_grad():
                    audio_array = self.model.generate(
                        **inputs,
                        semantic_temperature=settings.BARK_SEMANTIC_TEMP,
                        coarse_temperature=settings.BARK_COARSE_TEMP,
                        fine_temperature=settings.BARK_FINE_TEMP,
                        do_sample=True
                    )

                # Convert to numpy array
                audio_array = audio_array.cpu().numpy().squeeze()

                # Convert to AudioSegment
                if audio_array.dtype != np.int16:
                    audio_array = np.clip(audio_array, -1.0, 1.0)
                    audio_array = (audio_array * 32767).astype(np.int16)

                # Create temporary file for this chunk
                temp_chunk_wav = str(settings.TEMP_DIR / f"chunk_{i}_{uuid.uuid4()}.wav")
                wavfile.write(temp_chunk_wav, rate=sample_rate, data=audio_array)

                # Load as AudioSegment and add pause
                chunk_audio = AudioSegment.from_wav(temp_chunk_wav)

                # Add natural pause between chunks (300ms)
                if i < len(chunks) - 1:
                    silence = AudioSegment.silent(duration=300)
                    chunk_audio = chunk_audio + silence

                audio_segments.append(chunk_audio)

                # Clean up chunk file
                Path(temp_chunk_wav).unlink(missing_ok=True)

            # Concatenate all chunks
            logger.info("Concatenating audio chunks...")
            final_audio = sum(audio_segments)

            # Apply audio enhancement
            final_audio = self._enhance_audio(final_audio)

            # Resample to target sample rate if needed
            if sample_rate != settings.SAMPLE_RATE:
                final_audio = final_audio.set_frame_rate(settings.SAMPLE_RATE)

            # Export as MP3 with high quality
            final_audio.export(output_path, format="mp3", bitrate="192k")

            logger.info(f"Vocals generated successfully: {output_path}")

            return output_path

        except Exception as e:
            logger.error(f"Error generating vocals with Bark: {e}", exc_info=True)
            raise

    def _split_into_chunks(self, text: str, max_length: int = 200) -> list:
        """
        Split text into smaller chunks for better Bark quality
        Bark works best with shorter text segments

        Args:
            text: Formatted lyrics text
            max_length: Maximum characters per chunk

        Returns:
            List of text chunks
        """
        # Remove the context prompt for chunking
        if text.startswith('['):
            context_end = text.find(']')
            context = text[:context_end+1]
            text_body = text[context_end+1:].strip()
        else:
            context = ""
            text_body = text

        # Split by lines
        lines = [line.strip() for line in text_body.split('\n') if line.strip()]

        chunks = []
        current_chunk = ""

        for line in lines:
            # If adding this line would exceed max_length, start new chunk
            if len(current_chunk) + len(line) + 2 > max_length and current_chunk:
                # Add context to chunk
                chunk_with_context = f"{context}\n{current_chunk}".strip() if context else current_chunk
                chunks.append(chunk_with_context)
                current_chunk = line
            else:
                if current_chunk:
                    current_chunk += "\n" + line
                else:
                    current_chunk = line

        # Add the last chunk
        if current_chunk:
            chunk_with_context = f"{context}\n{current_chunk}".strip() if context else current_chunk
            chunks.append(chunk_with_context)

        return chunks

    def _enhance_audio(self, audio: AudioSegment) -> AudioSegment:
        """
        Apply audio enhancements for better quality

        Args:
            audio: Input audio segment

        Returns:
            Enhanced audio segment
        """
        # Normalize audio (prevent clipping and ensure consistent volume)
        audio = audio.normalize()

        # Apply gentle compression for more consistent volume
        # Reduce dynamic range by 6dB
        audio = audio.compress_dynamic_range(
            threshold=-20.0,
            ratio=4.0,
            attack=5.0,
            release=50.0
        )

        # Boost volume slightly for clarity (2dB)
        audio = audio + 2

        # Apply high-pass filter to remove low rumble (80Hz cutoff)
        audio = audio.high_pass_filter(80)

        logger.debug("Applied audio enhancements: normalize, compress, boost, filter")

        return audio

    def _format_for_singing(self, lyrics: str) -> str:
        """
        Format lyrics for Bark's expressive teacher-style reading
        Optimized for natural, warm delivery

        Args:
            lyrics: Raw lyrics text

        Returns:
            Formatted lyrics ready for Bark teacher-style reading
        """
        import re

        # First, clean the lyrics (remove structure labels)
        cleaned = self._add_shanty_rhythm(lyrics)

        if not self.singing_mode:
            # If not singing mode, return cleaned lyrics as-is
            return cleaned

        # Simple, effective prompt for teacher voice
        # Less is more with Bark - too much instruction can confuse it
        formatted = f"[Teacher reading a fun pirate story to children]\n{cleaned}"

        logger.debug(f"Formatted for teacher-style")

        return formatted

    def _add_shanty_rhythm(self, lyrics: str) -> str:
        """
        Clean and format lyrics for TTS
        Removes structure labels and formats pirate vocalizations

        Args:
            lyrics: Raw lyrics text

        Returns:
            Cleaned lyrics ready for TTS
        """
        import re

        # Remove structure labels (Verse 1:, Chorus:, etc.)
        cleaned = re.sub(r'Verse \d+:\s*', '', lyrics)
        cleaned = re.sub(r'Chorus:\s*', '', cleaned)
        cleaned = re.sub(r'Bridge:\s*', '', cleaned)
        cleaned = re.sub(r'Outro:\s*', '', cleaned)

        # Remove parentheses from pirate vocalizations but keep the words
        pirate_words = ['arr', 'Arr', 'yo-ho', 'Yo-ho', 'ahoy', 'Ahoy',
                       'avast', 'Avast', 'heave', 'Heave', 'shiver']

        for word in pirate_words:
            cleaned = cleaned.replace(f'({word}!)', f'{word}!')
            cleaned = cleaned.replace(f'({word.capitalize()}!)', f'{word.capitalize()}!')

        # Clean up excessive blank lines
        cleaned = re.sub(r'\n\s*\n\s*\n', '\n\n', cleaned)

        logger.debug(f"Cleaned lyrics for TTS:\n{cleaned}")

        return cleaned.strip()
